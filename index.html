<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Live Neural Net Visualization</title>
    <!-- Import TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: monospace; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="overlay">
    <h2>Neural Net Live Training</h2>
    <p>Epoch: <span id="epoch">0</span></p>
    <p>Loss: <span id="loss">0</span></p>
    <p>Resetting in: <span id="timer">10</span>s</p>
</div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Low res heatmap for performance, scaled up by CSS
    const heatMapRes = 50;
    let width, height;

    // TensorFlow variables
    let model;
    let dataPoints = [];
    let isTraining = false;
    let epochCount = 0;

    // Timer variables
    let startTime = Date.now();
    const RESET_INTERVAL = 10000; // 10 seconds

    // 1. Setup Canvas
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // 2. Generate Data (XOR Pattern - 4 clusters)
    function generateData() {
        dataPoints = [];
        const numPoints = 100;

        for (let i = 0; i < numPoints; i++) {
            // Random coordinate between -1 and 1
            let x = Math.random() * 2 - 1;
            let y = Math.random() * 2 - 1;

            // Logic: If signs match (++, --) it's class 0. If signs differ (+-, -+) it's class 1
            // We add noise so it's not perfect
            let label = (x * y > 0) ? 0 : 1;

            dataPoints.push({ x, y, label });
        }
    }

    // 3. Create Model
    function createModel() {
        if (model) model.dispose(); // Cleanup old model from memory

        model = tf.sequential();

        // Hidden Layer 1: 8 neurons, ReLU activation (learns non-linear shapes)
        model.add(tf.layers.dense({ inputShape: [2], units: 8, activation: 'relu' }));
        // Hidden Layer 2: 4 neurons
        model.add(tf.layers.dense({ units: 4, activation: 'relu' }));
        // Output Layer: 1 neuron, Sigmoid (outputs probability 0 to 1)
        model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));

        model.compile({
            optimizer: tf.train.adam(0.1), // Learning rate
            loss: 'binaryCrossentropy'
        });

        epochCount = 0;
    }

    // 4. Drawing Logic
    function draw() {
        // A. Draw Background Heatmap (The "Brain")
        // We create a grid of inputs covering the screen
        const inputs = [];
        for (let i = 0; i < heatMapRes; i++) {
            for (let j = 0; j < heatMapRes; j++) {
                let x = (i / heatMapRes) * 2 - 1;
                let y = (j / heatMapRes) * 2 - 1;
                inputs.push([x, y]);
            }
        }

        // Ask model to predict all grid points at once (tidy cleans up GPU memory)
        tf.tidy(() => {
            const inputTensor = tf.tensor2d(inputs);
            const predictions = model.predict(inputTensor).dataSync();

            // Draw the heatmap rectangles
            const w = width / heatMapRes;
            const h = height / heatMapRes;

            for (let i = 0; i < heatMapRes; i++) {
                for (let j = 0; j < heatMapRes; j++) {
                    const idx = i * heatMapRes + j;
                    const score = predictions[idx];

                    // Color interpolation: Blue (0) to Red (1)
                    ctx.fillStyle = `rgba(${score * 255}, 0, ${(1 - score) * 255}, 0.5)`;
                    ctx.fillRect(j * w, i * h, w + 1, h + 1); // +1 to fix tiny gaps
                }
            }
        });

        // B. Draw Data Points
        for (let p of dataPoints) {
            // Map -1..1 to screen coordinates
            let px = (p.x + 1) / 2 * width;
            let py = (p.y + 1) / 2 * height;

            ctx.beginPath();
            ctx.arc(px, py, 6, 0, Math.PI * 2);
            ctx.fillStyle = p.label === 0 ? '#00ccff' : '#ff0066'; // Cyan vs Pink
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
        }
    }

    // 5. Main Loop
    async function trainAndRender() {
        const timeElapsed = Date.now() - startTime;
        const timeLeft = Math.max(0, Math.ceil((RESET_INTERVAL - timeElapsed) / 1000));
        document.getElementById('timer').innerText = timeLeft;

        // Reset check
        if (timeElapsed > RESET_INTERVAL) {
            startTime = Date.now();
            generateData();
            createModel();
        }

        // Convert data to tensors for training
        const xs = tf.tensor2d(dataPoints.map(p => [p.x, p.y]));
        const ys = tf.tensor2d(dataPoints.map(p => [p.label]));

        // Train for one epoch (fit is async)
        const history = await model.fit(xs, ys, {
            epochs: 1,
            batchSize: 32,
            shuffle: true
        });

        // Update UI
        epochCount++;
        document.getElementById('epoch').innerText = epochCount;
        document.getElementById('loss').innerText = history.history.loss[0].toFixed(4);

        // Cleanup tensors to prevent memory leak
        xs.dispose();
        ys.dispose();

        // Draw the frame
        draw();

        // Keep loop going
        requestAnimationFrame(trainAndRender);
    }

    // Start everything
    generateData();
    createModel();
    trainAndRender();

</script>
</body>
</html>