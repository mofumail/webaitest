<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neural Field - Sharp & Bold</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        :root {
            --bg-color: #f2ede4; /* Richer aesthetic beige */
            --text-color: #4a4945;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-color); 
            font-family: 'Courier New', Courier, monospace;
            color: var(--text-color); 
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; bottom: 40px; right: 40px; pointer-events: none;
            background: rgba(255, 255, 255, 0.8); 
            padding: 15px 25px; border-radius: 0px;
            border: 2px solid var(--text-color);
            box-shadow: 8px 8px 0px rgba(0,0,0,0.1);
            z-index: 10;
        }
        h2 { margin: 0; font-weight: 900; text-transform: uppercase; font-size: 1rem; }
        p { margin: 5px 0 0 0; font-size: 0.7rem; font-weight: bold; }
    </style>
</head>
<body>

<div id="overlay">
    <h2>Neural Logic v2</h2>
    <p>LOSS: <span id="loss">0</span> / RESET: <span id="timer">10</span>s</p>
</div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Palette: Sharp, high-contrast but soothing
    const COLORS = {
        bg: '#f2ede4',
        blue: { r: 65, g: 105, b: 225 }, // Royal Blue
        red: { r: 220, g: 20, b: 60 }     // Crimson
    };

    // Huge, Packed Orbs
    const orbRadius = 85; 
    const spacing = 130; // Closer spacing = less whitespace
    let width, height, rows, cols;
    
    let model, dataPoints = [], epochCount = 0;
    let startTime = Date.now();
    const RESET_INTERVAL = 10000;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cols = Math.ceil(width / spacing) + 1;
        rows = Math.ceil(height / spacing) + 1;
    }
    window.addEventListener('resize', resize);
    resize();

    function generateData() {
        dataPoints = [];
        // We generate data but don't draw it. 
        // We use a "Radial XOR" to create complex circular shapes that warp
        const centerDist = Math.random() * 0.5 + 0.2;
        for (let i = 0; i < 80; i++) {
            let x = Math.random() * 2 - 1; 
            let y = Math.random() * 2 - 1;
            let dist = Math.sqrt(x*x + y*y);
            let label = dist > centerDist ? 0 : 1; 
            
            // Flip bits randomly for "lossy" chaos
            if(Math.random() > 0.92) label = 1 - label;
            
            dataPoints.push({ x, y, label });
        }
    }

    function createModel() {
        if (model) model.dispose();
        model = tf.sequential();
        
        // tanh makes the boundaries much more organic and "swingy"
        model.add(tf.layers.dense({ 
            inputShape: [2], 
            units: 12, 
            activation: 'tanh',
            kernelInitializer: 'randomNormal' 
        }));
        model.add(tf.layers.dense({ 
            units: 1, 
            activation: 'sigmoid' 
        }));

        // MAX LEARNING RATE for maximum visual movement
        model.compile({ 
            optimizer: tf.train.adam(0.6), 
            loss: 'binaryCrossentropy' 
        });
        epochCount = 0;
    }

    function lerpColor(val) {
        const r = Math.floor(COLORS.blue.r + (COLORS.red.r - COLORS.blue.r) * val);
        const g = Math.floor(COLORS.blue.g + (COLORS.red.g - COLORS.blue.g) * val);
        const b = Math.floor(COLORS.blue.b + (COLORS.red.b - COLORS.blue.b) * val);
        return `rgb(${r}, ${g}, ${b})`;
    }

    async function draw() {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        const gridInputs = [];
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                let x = (j / (cols-1)) * 2 - 1;
                let y = (i / (rows-1)) * 2 - 1;
                gridInputs.push([x, y]);
            }
        }

        const preds = tf.tidy(() => {
            return model.predict(tf.tensor2d(gridInputs)).dataSync();
        });

        let idx = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const score = preds[idx++];
                // Stagger every other row for a honeycomb-like pack (less whitespace)
                const xOffset = (i % 2 === 0) ? 0 : spacing / 2;
                const posX = j * spacing + xOffset;
                const posY = i * spacing;

                const pulse = Math.sin(Date.now() / 400 + (i + j)) * 8;
                
                ctx.beginPath();
                ctx.arc(posX, posY, orbRadius + pulse, 0, Math.PI * 2);
                ctx.fillStyle = lerpColor(score);
                ctx.fill();
                
                // Add a very subtle sharp ring to keep it looking crisp
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }

    async function loop() {
        const elapsed = Date.now() - startTime;
        document.getElementById('timer').innerText = Math.max(0, Math.ceil((RESET_INTERVAL - elapsed) / 1000));

        if (elapsed > RESET_INTERVAL) {
            startTime = Date.now();
            generateData();
            createModel();
        }

        const xs = tf.tensor2d(dataPoints.map(p => [p.x, p.y]));
        const ys = tf.tensor2d(dataPoints.map(p => [p.label]));
        
        // High learning rate + low epochs = big visual shifts
        const history = await model.fit(xs, ys, { epochs: 1, silent: true });
        
        document.getElementById('loss').innerText = history.history.loss[0].toFixed(3);

        xs.dispose();
        ys.dispose();

        await draw();
        requestAnimationFrame(loop);
    }

    generateData();
    createModel();
    loop();
</script>
</body>
</html>
