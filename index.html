<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aesthetic Neural Field</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        :root {
            --bg-color: #fdfbf7; /* Soothing off-white/beige */
            --text-color: #5d5c58;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-color); 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color); 
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 30px; left: 30px; pointer-events: none;
            background: rgba(255, 255, 255, 0.6); 
            padding: 20px; border-radius: 15px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.05);
        }
        h2 { margin: 0 0 10px 0; font-weight: 300; letter-spacing: 1px; font-size: 1.2rem; }
        p { margin: 5px 0; font-size: 0.8rem; opacity: 0.8; text-transform: uppercase; letter-spacing: 1px; }
    </style>
</head>
<body>

<div id="overlay">
    <h2>Neural Field</h2>
    <p>Epoch: <span id="epoch">0</span></p>
    <p>Loss: <span id="loss">0</span></p>
    <p>Reset: <span id="timer">10</span>s</p>
</div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Aesthetic Colors (Soothing Tones)
    const COLORS = {
        bg: '#fdfbf7',
        blue: { r: 127, g: 179, b: 213 }, // Muted Sky Blue
        red: { r: 233, g: 150, b: 122 },  // Dark Salmon / Soothing Red
        pointStroke: 'rgba(255, 255, 255, 0.8)'
    };

    // Grid Settings
    const orbSpacing = 35; 
    let width, height, rows, cols;
    
    let model, dataPoints = [], epochCount = 0;
    let startTime = Date.now();
    const RESET_INTERVAL = 10000;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cols = Math.ceil(width / orbSpacing);
        rows = Math.ceil(height / orbSpacing);
    }
    window.addEventListener('resize', resize);
    resize();

    function generateData() {
        dataPoints = [];
        for (let i = 0; i < 60; i++) {
            let x = Math.random() * 2 - 1; 
            let y = Math.random() * 2 - 1;
            // XOR logic: clusters in opposite corners
            let label = (x * y > 0) ? 0 : 1; 
            dataPoints.push({ x, y, label });
        }
    }

    function createModel() {
        if (model) model.dispose();
        model = tf.sequential();
        model.add(tf.layers.dense({ inputShape: [2], units: 8, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 4, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
        model.compile({ optimizer: tf.train.adam(0.1), loss: 'binaryCrossentropy' });
        epochCount = 0;
    }

    // Helper to interpolate between our two soothing colors
    function lerpColor(val) {
        const r = Math.floor(COLORS.blue.r + (COLORS.red.r - COLORS.blue.r) * val);
        const g = Math.floor(COLORS.blue.g + (COLORS.red.g - COLORS.blue.g) * val);
        const b = Math.floor(COLORS.blue.b + (COLORS.red.b - COLORS.blue.b) * val);
        return `rgb(${r}, ${g}, ${b})`;
    }

    async function draw() {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // 1. Prepare grid inputs for the model
        const gridInputs = [];
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                let x = (j / cols) * 2 - 1;
                let y = (i / rows) * 2 - 1;
                gridInputs.push([x, y]);
            }
        }

        // 2. Get predictions
        const preds = tf.tidy(() => {
            return model.predict(tf.tensor2d(gridInputs)).dataSync();
        });

        // 3. Draw Orbs
        let idx = 0;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const score = preds[idx++];
                const posX = j * orbSpacing + orbSpacing/2;
                const posY = i * orbSpacing + orbSpacing/2;

                // Subtle pulse based on time
                const pulse = Math.sin(Date.now() / 1000 + (i+j)*0.2) * 2;
                
                ctx.beginPath();
                ctx.arc(posX, posY, 4 + pulse, 0, Math.PI * 2);
                ctx.fillStyle = lerpColor(score);
                ctx.fill();
            }
        }

        // 4. Draw Original Data Points (Small rings)
        for (let p of dataPoints) {
            let px = (p.x + 1) / 2 * width;
            let py = (p.y + 1) / 2 * height;
            
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fillStyle = p.label === 0 ? lerpColor(0) : lerpColor(1);
            ctx.strokeStyle = COLORS.pointStroke;
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
        }
    }

    async function loop() {
        const elapsed = Date.now() - startTime;
        document.getElementById('timer').innerText = Math.max(0, Math.ceil((RESET_INTERVAL - elapsed) / 1000));

        if (elapsed > RESET_INTERVAL) {
            startTime = Date.now();
            generateData();
            createModel();
        }

        const xs = tf.tensor2d(dataPoints.map(p => [p.x, p.y]));
        const ys = tf.tensor2d(dataPoints.map(p => [p.label]));

        const history = await model.fit(xs, ys, { epochs: 1, silent: true });
        
        epochCount++;
        document.getElementById('epoch').innerText = epochCount;
        document.getElementById('loss').innerText = history.history.loss[0].toFixed(3);

        xs.dispose();
        ys.dispose();

        await draw();
        requestAnimationFrame(loop);
    }

    generateData();
    createModel();
    loop();
</script>
</body>
</html>
